// Includes and constants
#define PI          3.141592654
#define HSV2RGB_K  vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0)
#define HSV2RGB(c) (c.z * mix(HSV2RGB_K.xxx, clamp(abs(fract(c.xxx + HSV2RGB_K.xyz) * 6.0 - HSV2RGB_K.www) - HSV2RGB_K.xxx, 0.0, 1.0), c.y))
const ivec2 char_I = ivec2(-2130247680, 470818880);
const ivec2 char_M = ivec2(608731136, 577546578);
const ivec2 char_O = ivec2(608632832, 474253586);
const ivec2 char_S = ivec2(71761920, 474220770);
const ivec2 char_Y = ivec2(-2130575360, 574902336);

ivec2 text_box_chars = ivec2(62, 16);

float draw_char(vec2 coord, ivec2 char) {
    int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;
    int num = pos_id < 32 ? char.x : char.y;
    int val;

    if(pos_id < 32) {
        val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));
    } else {
        // Handle the case where pos_id is greater than or equal to 32
        // by using a different bit manipulation technique.
        int shifted_pos_id = pos_id - 32;
        int pow_val = int(pow(2.0, float(shifted_pos_id)));
        val = (num / pow_val);
        val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1
    }

    float col = val == 0 ? 0.0 : 1.0;

    return col;
}

vec3 draw_text(vec2 coord, vec2 pos) {
    coord += pos;
    coord *= 2.0;
    int charIndex = int(coord.x);
    coord.x -= float(int(coord.x));

    ivec2 text_string_2[7];
    ivec2 current_char = text_string_2[0]; // Initialize with a default character

    if(charIndex == 1)
        current_char = ivec2(char_S);
    else if(charIndex == 2)
        current_char = ivec2(char_Y);
    else if(charIndex == 3)
        current_char = ivec2(char_M);
    else if(charIndex == 4)
        current_char = ivec2(char_M);
    else if(charIndex == 5)
        current_char = ivec2(char_I);
    else if(charIndex == 6)
        current_char = ivec2(char_O);

    // Calculate the color for the character and return it as a vec3.
    return vec3(draw_char(coord, current_char));
}

float scoreTime() {
    return iTime - 4.;
}
float drumTime() {
    return iTime - 4. - 8. * beatdur;
}
float timeSinceKick() {
    float t = drumTime();
    return (t > 0.) ? mod(t, 2. * beatdur) : 20.;
}
float timeSinceSnare() {
    float t = drumTime() - beatdur;
    return (t > 0.) ? mod(t, 2. * beatdur) : 20.;
}
vec4 Noise(in ivec2 x) {
    return texture(iChannel0, (vec2(x) + 0.5) / 256.0, -100.0);
}
vec2 lensDistortion(vec2 p, float dist) {
    return (dist > 0.) ? p * (1. + dist * length(p)) : p / (1. - dist * length(p));
}

// Function for rendering the outer sky
vec3 outerSkyRender(vec3 rd, vec2 uv) {
// Sun direction and color
    float intensity = 1. + 5.*exp(-5.*timeSinceKick());

    vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));
    vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.0002 * smoothstep(1.0, 4.0, iTime) + (intensity * 0.0001)));

    vec3 col = HSV2RGB(vec3(0.5, 0.00, 0.004));
   // Arpeggio animation

    for(float i = 0.; i < 17.; i++) {

        float timeSinceArpUp = mod(scoreTime() - i * 0.125 * beatdur, 4. * beatdur);
        float timeSinceArpDown = mod(scoreTime() - 4. * beatdur + i * 0.125 * beatdur, 4. * beatdur);
        float timeSinceNote = min(timeSinceArpUp, timeSinceArpDown);
        timeSinceNote = (scoreTime() >= i * 0.125 * beatdur) ? timeSinceNote : 10.;

        intensity = 1. * exp(-10. * timeSinceNote) + exp(-8. * timeSinceNote);
        float d = length(uv + vec2(1.62, 0.0) - vec2(0., 0.05 * (i - 8.))) - 0.01;
        d = min(d, length(uv + vec2(-1.62, 0.0) - vec2(0., 0.05 * (i - 8.))) - 0.01);

        col += intensity * smoothstep(0.01, 0.0, d) * vec3(1.0, 0.5, 0.5) * 2.;
        col += intensity * smoothstep(0.0, 0.01, d) * vec3(1.0, 0.5, 0.5) * 0.001 / (d * d + 0.01);
    }

  // Sun add to col
    col += sunCol / pow((1.002 - dot(sunDir, rd)), 1.9);

  // Horizon light modifier
    vec3 gcol = HSV2RGB(vec3(1.0, 0.4, 0.001 * smoothstep(1.0, 4.0, iTime) + intensity * 0.0005));

  // Atmosphere air color
    col += HSV2RGB(vec3(0.97, 0.0, 0.1 * smoothstep(1.0, 4.0, iTime)));
  // add glow to sky
    col += gcol / max(abs(rd.y), 0.0);

  // add stars to sky
    vec3 ray = vec3(2.0 * rd.xy, 1.0);
    float offset = iTime * 0.06;
    float speed = 0.2;
    vec3 stp = ray / max(abs(ray.x), abs(ray.y));
    vec3 pos = stp + 0.5;
    for(int i = 0; i < 10; i++) {
        vec2 noise = Noise(ivec2(pos.xy)).xy;
        float z = fract(noise.x - offset);
        float d = 20.0 * smoothstep(1.0, 4.0, iTime) * z - pos.z;
        float w = pow(max(0.0, 1.0 - 2.0 * length(fract(pos.xy) - 0.5)), 15.0);
        vec3 c = max(vec3(0), vec3(1.0 - abs(d + speed * 0.5) / speed, 1.0 - abs(d) / speed, 1.0 - abs(d) / speed));
        col += (1.0 - z) * c * w;
        pos += stp;
    }

    return col;
}

// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm
float rayPlane(vec3 ro, vec3 rd, vec4 p) {
  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
}
// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float box(vec2 p, vec2 b) {
  vec2 d = abs(p)-b;
  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}
// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm
vec2 raySphere(vec3 ro, vec3 rd, vec4 dim) {
  vec3 ce = dim.xyz;
  float ra = dim.w;
  vec3 oc = ro - ce;
  float b = dot( oc, rd );
  float c = dot( oc, oc ) - ra*ra;
  float h = b*b - c;
  if( h<0.0 ) return vec2(-1.0); // no intersection
  h = sqrt( h );
  return vec2( -b-h, -b+h );
}

float heightFactor(vec2 p) {
  return 4.0*smoothstep(7.0, 0.5, abs(p.x))+.5;
}

// License: Unknown, author: Unknown, found: don't remember
float hash(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);
}
// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr
float vnoise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
    
  vec2 u = f*f*(3.0-2.0*f);

  float a = hash(i + vec2(0.0,0.0));
  float b = hash(i + vec2(1.0,0.0));
  float c = hash(i + vec2(0.0,1.0));
  float d = hash(i + vec2(1.0,1.0));
  
  float m0 = mix(a, b, u.x);
  float m1 = mix(c, d, u.x);
  float m2 = mix(m0, m1, u.y);
  
  return m2;
}
float hifbm(vec2 p) {
  p *= 0.25;
  float hf = heightFactor(p);
  const float aa = 0.5;
  const float pp = 2.0-0.;

  float sum = 0.0;
  float a   = 1.0;
  
  for (int i = 0; i < 5; ++i) {
    sum += a*vnoise(p);
    a *= aa;
    p *= pp;
  }
  
  return hf*sum;
}

float hiheight(vec2 p) {
  return hifbm(p);
}
float lofbm(vec2 p) {
  p *= 0.25;
  float hf = heightFactor(p);
  const float aa = 0.5;
  const float pp = 2.0-0.;

  float sum = 0.0;
  float a   = 1.0;
  
  for (int i = 0; i < 3; ++i) {
    sum += a*vnoise(p);
    a *= aa;
    p *= pp;
  }
  
  return hf*sum;
}
float loheight(vec2 p) {
  return lofbm(p)-0.5;
}
// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/
float mod1(inout float p, float size) {
  float halfsize = size*0.5;
  float c = floor((p + halfsize)/size);
  p = mod(p + halfsize, size) - halfsize;
  return c;
}
// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm
float segment(vec2 p, vec2 a, vec2 b) {
  vec2 pa = p-a, ba = b-a;
  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
  return length(pa - ba*h);
}

const float mountainPos = -30.0;


vec3 mountainRender(vec3 col, vec3 ro, vec3 rd, bool flip) {
vec3 sunDir= normalize(vec3(0.0, 0.25, 1.0));

  const vec3 tpn = normalize(vec3(0.0, 0.0, 1.0));
  const vec4 tpdim = vec4(tpn, mountainPos);
  float tpd = rayPlane(ro, rd, tpdim);


  vec3 pp = ro+rd*tpd;
  vec2 p = pp.xy;
  const float cw = 1.0-0.25;
  float hz = 0.0*iTime+1.0;
  float lo = loheight(vec2(p.x, hz));
  vec2 cp = p;
  float cn = mod1(cp.x, cw);


  const float reps = 1.0;

  float d = 1E3;

  for (float i = -reps; i <= reps; ++i) {
    float x0 = (cn -0.5 + (i))*cw;
    float x1 = (cn -0.5 + (i + 1.0))*cw;
  
    float y0 = hiheight(vec2(x0, hz));
    float y1 = hiheight(vec2(x1, hz));
    
    float dd = segment(cp, vec2(-cw*0.5 + cw * float(i), y0), vec2(cw*0.5 + cw * float(i), y1));
    
    d = min(d, dd);
  }

  vec3 mcol = col;
  float aa = fwidth(p.y);
  if ((dFdy(d) < 0.0) == !flip) {
    mcol *= mix(0.0, 1.0, smoothstep(aa, -aa, d-aa));
    mcol += HSV2RGB(vec3(0.0, 0.35, 0.0))*smoothstep(0.0, 5.0, lo-p.y);
    col = mcol;
  }
  vec3 rcol = HSV2RGB(vec3(clamp((0.5*(rd.x)), 0.0, 0.008), 0.75, 0.125));

  float sd = 1.0001-((dot(sunDir, rd)));


  col += rcol/(abs(d)+0.002+800.*sd*sd* timeSinceKick()/5.0);

  return col;  
}
 vec3 skyCol       = HSV2RGB(vec3(0.58, 0.86, 1.0));
 vec3 sunDir2      = normalize(vec3(0., 0.82, 1.0));

vec3 skyRender(vec3 ro, vec3 rd) {
  vec3 col = vec3(0.0);
  col += 0.025*skyCol;
  col += skyCol*0.0033/pow((1.001+((dot(sunDir2, rd)))), 2.0);

  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));
  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));
  float tp = tp1;
  tp = max(tp0,tp1);


  if (tp1 > 0.0) {
    vec3 pos  = ro + tp1*rd;
    vec2 pp = pos.xz;
    float db = box(pp, vec2(5.0, 9.0))-3.0;
    
    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);
    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));
    col += 0.25*sqrt(skyCol)*max(-db, 0.0);
  }

  if (tp0 > 0.0) {
    vec3 pos  = ro + tp0*rd;
    vec2 pp = pos.xz;
    float ds = length(pp) - 0.5;
    
    col += (0.25)*skyCol*exp(-.5*max(ds, 0.0));
  }

  return clamp(col, 0.0, 10.0);
}



// License: Unknown, author: Unknown, found: don't remember
float tanh_approx(float x) {
  //  Found this somewhere on the interwebs
  //  return tanh(x);
  float x2 = x*x;
  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);
}
const vec3 speCol1      = HSV2RGB(vec3(0.60, 0.25, 1.0));
const vec3 speCol2      = HSV2RGB(vec3(0.55, 0.25, 1.0));
const vec3 diffCol1     = HSV2RGB(vec3(0.60, 0.90, 1.0));
const vec3 diffCol2     = HSV2RGB(vec3(0.55, 0.90, 1.0));

vec4 sphere(vec3 ro, vec3 rd, vec4 sdim) {
  vec2 si = raySphere(ro, rd, sdim);
  
  vec3 nsp = ro + rd*si.x;

  const vec3 lightPos1   = vec3(0.0, 10.0, 10.0);
  const vec3 lightPos2   = vec3(0.0, -80.0, 10.0);
  
  vec3 nld1   = normalize(lightPos1-nsp); 
  vec3 nld2   = normalize(lightPos2-nsp); 
  
  vec3 nnor   = normalize(nsp - sdim.xyz);

  vec3 nref   = reflect(rd, nnor);

  const float sf = 4.0;
  float ndif1 = max(dot(nld1, nnor), 0.0);
  ndif1       *= ndif1;
  vec3 nspe1  = pow(speCol1*max(dot(nld1, nref), 0.0), sf*vec3(1.0, 0.8, 0.5));

  float ndif2 = max(dot(nld2, nnor), 0.0);
  ndif2       *= ndif2;
  vec3 nspe2  = pow(speCol2*max(dot(nld2, nref), 0.0), sf*vec3(0.9, 0.5, 0.5));

  vec3 nsky   = skyRender(nsp, nref);
  float nfre  = 1.0+dot(rd, nnor);
  nfre        *= nfre;

  vec3 scol = vec3(0.0); 
  scol += nsky*mix(vec3(0.25), vec3(0.5, 0.5, 1.0), nfre);
  scol += diffCol1*ndif1;
  scol += diffCol2*ndif2;
  scol += nspe1;
  scol += nspe2;
  
  float t = tanh_approx(2.0*(si.y-si.x)/sdim.w);
  
  return vec4(scol, t);
}

vec3 sphereRender(vec3 ro, vec3 rd) {
  vec3 skyCol = skyRender(ro, rd);
  vec3 col = skyCol;
  const vec4 sdim0 = vec4(vec3(0.0), 2.0);
  vec4 scol0 = sphere(ro, rd, sdim0);
  col = mix(col, scol0.xyz, scol0.w);
  return col;
}

vec3 sphereEffect(vec2 p) {
  const float fov = tan(TAU/6.0);
  const vec3 ro = 1.0*vec3(0.0, 2.0, 5.0);
  const vec3 la = vec3(0.0, 0.0, 0.0);
  const vec3 up = vec3(0.0, 1.0, 0.0);

  vec3 ww = normalize(la - ro);
  vec3 uu = normalize(cross(up, ww));
  vec3 vv = cross(ww,uu);
  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);

  vec3 col = sphereRender(ro, rd);
  
  return col;
}


vec3 cityOfKali(vec2 p) {
  vec2 c = -vec2(0.5, 0.5)*1.12;

  float s = 2.0;
  vec2 kp = p/s;
 
  const float a = PI/4.0;
  const vec2 n = vec2(cos(a), sin(a));

  float ot2 = 1E6;
  float ot3 = 1E6;
  float n2 = 0.0;
  float n3 = 0.0;

  const float mx = 12.0;
  for (float i = 0.0; i < mx; ++i) {
    float m = (dot(kp, kp));
    s *= m;
    kp = abs(kp)/m + c;
    float d2 = (abs(dot(kp,n)))*s;
    if (d2 < ot2) {
      n2 = i;
      ot2 = d2;
    }
    float d3 = (dot(kp, kp));
    if (d3 < ot3) {
      n3 = i;
      ot3 = d3;
    }
  }
  vec3 col = vec3(0.0);
  n2 /= mx;
  n3 /= mx;
  col += 0.15*(HSV2RGB(vec3(0.0, 0.90, 0.025)));
  col += HSV2RGB(vec3(0.0, 0.85, 0.00000025))/(ot3*ot3+0.000000025);
  return col;
}
#define PI_2        (0.5*PI)
// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV
float atan_approx(float y, float x) {
  float cosatan2 = x / (abs(x) + abs(y));
  float t = PI_2 - cosatan2 * PI_2;
  return y < 0.0 ? -t : t;
}
vec3 toSpherical(vec3 p) {
  float r   = length(p);
  float t   = acos(p.z/r);
  float ph  = atan_approx(p.y, p.x);
  return vec3(r, t, ph);
}

 
#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))
vec3 outerSkyRender2(vec3 ro, vec3 rd) {
 vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.0002 * smoothstep(1.0, 4.0, iTime) ));
  vec3 center = ro+vec3(-100.0, 40.0, 100.0);
  vec4 sdim = vec4(center, 50);
  vec2 pi = raySphere(ro, rd, sdim);
  const vec3 pn = normalize(vec3(0., 1.0, -0.8));
  vec4 pdim = vec4(pn, -dot(pn, center)); 
  float ri = rayPlane(ro, rd, pdim);

  vec3 col = vec3(0.0);
  vec3 sunDir= normalize(vec3(0.0, 0.1-sin(iTime/5.)/3.0, 1.0));
  //atmosphere light
   col += HSV2RGB(vec3(0.97, 0.0, 0.1 * smoothstep(1.0, 4.0, iTime)));

  col += sunCol/pow((1.001-((dot(sunDir, rd)))), 2.0);

  if (pi.x != -1.0) {
    vec3 pp = ro + rd*pi.x;
    vec3 psp= pp-sdim.xyz;
    vec3 pn = normalize(pp-sdim.xyz);
    psp = psp.zxy;
    psp.yz *= ROT(-0.5);
    psp.xy *= ROT(0.025*iTime);
    vec3 pss= toSpherical(psp);
    vec3 pcol = vec3(0.0);
    float dif = max(dot(pn, sunDir), 0.0);
    vec3 sc = 2000.0*sunCol;
    pcol += sc*dif;
    pcol += (cityOfKali(pss.yz))*smoothstep(0.125, 0.0, dif);
    pcol += pow(max(dot(reflect(rd, pn), sunDir), 0.0), 9.0)*sc;
    col = mix(col, pcol, tanh_approx(0.125*(pi.y-pi.x)));
    
  }

  vec3 gcol = vec3(0.0);

  vec3 rp = ro + rd*ri;
  float rl = length(rp-center);
  float rb = 1.55*sdim.w;
  float re = 2.45*sdim.w;
  float rw = 0.1*sdim.w;


  col += gcol/max(abs(rd.y), 0.0033);

return col;
}


// Function to calculate the value of an equilateral triangle
float equilateralTriangle(vec2 p) {
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    if(p.x + k * p.y > 0.0)
        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
    p.x -= clamp(p.x, -2.0, 0.0);
    return -length(p) * sign(p.y);
}

// Function for rendering the triangle
vec3 triRender(vec3 col, vec3 ro, vec3 rd) {
  // Triangle fill color
    vec3 fillColor = vec3(0.005, 0.0, 0.0);

  // Triangle calculations
    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
    float tpd = rayPlane(ro, rd, tpdim);
    vec3 pp = ro + rd * tpd;
    vec2 p = pp.xy;
    p.y -= 1.1730;

    // Triangle resize
    p *= 0.5;
  // Triangle y offset

  // Triangle inner glow factor
    float hoff = dot(sin(iTime), p.y);
    vec3 gcol = HSV2RGB(vec3(0.003, 0.8, hoff*0.01));
  // Triangle displacement
    float dt = equilateralTriangle(p);

  // Triangle to scene visibility ratio
    col = dt < 0.0 ? fillColor : col;

  // Triangle edge glow modification
    col += (gcol / max(abs(dt), 0.002));
    
    return col;
}

// Function for rendering the ground
vec3 groundRender(vec3 col, vec3 ro, vec3 rd, vec2 p) {
    const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));
    const vec4 gpdim = vec4(gpn, 0.0);
    float gpd = rayPlane(ro, rd, gpdim);

    if(gpd < 0.0) {
        return col;
    }

  // Tiles reflection modifier
    vec3 gp = ro + rd * gpd;
    float gpfre = 1.15 + dot(rd, gpn);
    gpfre *= gpfre;
    gpfre *= gpfre;

    vec3 grr = reflect(rd, gpn);

    vec2 ggp = gp.xz;
    ggp.y += iTime * 0.5;
    float dfy = dFdy(ggp.y);
    float gcf = sin(ggp.x) * sin(ggp.y);
    vec2 ggn;

  // Calculate the modulus
    vec2 c = floor(ggp);
    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);
    ggn = c;

    float ggd = min(abs(ggp.x), abs(ggp.y));

  // Tiles lines color modifier
    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005 * smoothstep(1.0, 4.0, iTime) + exp(-18. * timeSinceSnare()) * 0.01));

    vec3 rcol = outerSkyRender(grr, p);
    rcol = triRender(rcol, gp, grr);

  // Tiles calculations
    col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);

  // Ground horizon reflection color filter
    rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));
  // Ground reflection factor
    col += rcol * gpfre / 2.0;

    return col;
}
// Function for rendering the triangle
vec3 triRender2(vec3 col, vec3 ro, vec3 rd) {
  // Triangle fill color
    vec3 fillColor = vec3(0.005, 0.0, 0.0);

  // Triangle calculations
    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
    float tpd = rayPlane(ro, rd, tpdim);
    vec3 pp = ro + rd * tpd;
    vec2 p = pp.xy;
    p.y -= 2.05;
    p.x -= 5.0;

    // Apply rotation to the triangle around its center
    float rotationAngle = iTime/8.0; // You can modify this based on your time needs
    mat2 rotationMatrix = mat2(cos(rotationAngle), -sin(rotationAngle), sin(rotationAngle), cos(rotationAngle));
    p = rotationMatrix * p; // Rotate

    // Triangle resize
    p *= 0.65;
  // Triangle y offset
    float angle = iTime; // You can adjust the speed by multiplying iTime with a constant
    float radius = 1.0;  // Adjust the radius as needed
  // Triangle inner glow factor
    float x = cos(angle) * radius;
    float y = sin(angle) * radius;

    float hoff = dot(x, p.x) + dot(y, p.y);
    vec3 gcol = HSV2RGB(vec3(0.01, 0.7, hoff*0.01));
  // Triangle displacement
    float dt = equilateralTriangle(p);

  // Triangle to scene visibility ratio
    col = dt < 0.0 ? fillColor : col;

  // Triangle edge glow modification
    col += (gcol / max(abs(dt), 0.002));
    return col;
}

// Function for rendering the ground
vec3 groundRender2(vec3 col, vec3 ro, vec3 rd, vec2 p) {
   const vec3 gpn = normalize(vec3(0.0, 2.0, 0.01));
    const vec4 gpdim = vec4(gpn, 0.0);
    float gpd = rayPlane(ro, rd, gpdim);

    if(gpd < 0.0) {
        return col;
    }

  // Tiles reflection modifier
    vec3 gp = ro + rd * gpd;
    float gpfre = 1.15 + dot(rd, gpn);
    gpfre *= gpfre;

    vec3 grr = reflect(rd, gpn);
    vec2 ggp = gp.xz;
    ggp.y += iTime * 0.5;

    float dfy = dFdy(ggp.y);
    float gcf = sin(ggp.x+1.1) * sin(ggp.y);
    vec2 ggn;

  // Calculate the modulus
    vec2 c = floor(ggp);
    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);
    ggn = c;

    float ggd = min(abs(ggp.x), abs(ggp.y));

  // Tiles lines color modifier
    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005 * smoothstep(1.0, 4.0, iTime) + exp(-18. * timeSinceSnare()) * 0.01));

    vec3 rcol = outerSkyRender2(gp, grr);
    rcol = mountainRender(rcol, gp, grr, true);;

    rcol = triRender2(rcol, gp, grr);

  // Tiles calculations
    col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);

  // Ground horizon reflection color filter
    rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));
  // Ground reflection factor
    col += rcol * gpfre / 2.0;

    return col;
}
vec3 sceneOne(vec2 uv) {
    float dist = 1.0 * smoothstep(4.0, 0.0, iTime);
    // "Acceleration effect": distort picture on riser
    float riserTime = (scoreTime() - 40. * beatdur) / (7. * beatdur);
    riserTime = clamp(riserTime, 0., 1.);
    dist += riserTime * (1. - 0.167 / (1. - riserTime));
    uv = lensDistortion(uv, dist);

    const float fov = 2.0;
    // Camera location
    vec3 ro = 1.0 * vec3(0.0, 0.5, -22.0 + (iTime * 0.3) + smoothstep(1.0, 4.0, iTime) * 10.0);
     // Camera look at
    vec3 la = vec3(0.0, 1.5, 0.0);
    vec3 up = vec3(0.0, 1.0, 0.0);
  // camera coordinate system
    vec3 ww = normalize(la - ro);
    vec3 uu = normalize(cross(up, ww));
    vec3 vv = cross(ww, uu);
  // ray direction
    vec3 rd = normalize(-uv.x * uu + uv.y * vv + fov * ww);
      // Rendering process
    vec3 col = outerSkyRender(rd, uv);
    col = groundRender(col, ro, rd, uv);
    col = triRender(col, ro, rd);


    return col * smoothstep(1.0, 4.0, iTime);

}
vec3 sceneTwo(vec2 uv) {

    const float fov = 2.0;
    // Camera location
    vec3 ro = 1.0 * vec3(2.0, 0.5, -15.0 + smoothstep(1.0, 4.0, iTime) * 10.0);
     // Camera look at
    vec3 la = vec3(0.0, 1.5, 100.0);
    vec3 up = vec3(0.0, 1.0, 0.0);
  // camera coordinate system
    vec3 ww = normalize(la - ro);
    vec3 uu = normalize(cross(up, ww));
    vec3 vv = cross(ww, uu);
  // ray direction
    vec3 rd = normalize(-uv.x * uu + uv.y * vv + fov * ww);
      // Rendering process
    vec3 col = outerSkyRender2(ro, rd);
         col = mountainRender(col, ro, rd, false);

    col = groundRender2(col, ro, rd, uv);
    col = triRender2(col, ro, rd);

    return col * smoothstep(1.0, 4.0, iTime);

}
// Main image rendering function
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;

  // Convert and adjust pixel coordinates
    float dist = 1.0 * smoothstep(4.0, 0.0, iTime);

    uv = lensDistortion(uv, dist);

    vec3 col = sceneOne(uv);
    if(scoreTime() > 47. * beatdur) {
        // Fade from white to black on clap
        float tClap = scoreTime() - 47. * beatdur;
        col = col = draw_text(uv, vec2(2.0, 0.4)) * exp(-8. * tClap) * smoothstep(1., 0., tClap);
    }
    if(scoreTime() > 48. * beatdur) {
        col = sceneTwo(uv);
    }

    // Time varying pixel color
  // Set the final pixel color
    fragColor = vec4(col, 1.0);
}
